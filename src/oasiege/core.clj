(ns oasiege.core
  (:require [clojure.spec :as s]
            [swagger.reader.json :as json]
            [swagger.reader.yaml :as yaml]
            [clojure.spec.gen :as gen]
            [miner.strgen :as sg]
            swagger.spec
            clojure.string))


;; --------------------------------------------------------
;; Spec generation


(defn prefixed-key [prefix key]
  (keyword (namespace prefix)
    (str (name prefix) "." (name key))))


(defn regexp-spec [pattern]
  (let [regexp (re-pattern pattern)]
    `(s/with-gen (s/and string? #(re-matches ~regexp %))
      #(sg/string-generator ~regexp))))


(s/def ::structval (s/or
                     :int integer?
                     :str string?
                     :bool boolean?
                     :struct (s/map-of string? ::structval)
                     :seq (s/every ::structval)))


(defn value-spec [{type-name :type pattern :pattern schema :schema
                   :as desc}]
  (cond
    (= type-name "integer") `integer?
    (= type-name "string") `string?
    pattern (regexp-spec pattern)
    schema ::structval ;;;; TODO Take in account acual JSON schema (if present)
    (= type-name "object") ::structval
    true (throw (ex-info "Cannot create spec for this value."
                  {:type ::error
                   :description desc}))))


(defn request-spec [api]
  ;; It is possible to use s/def-impl do add apec definitions while avoiding macroses
  ;; but then spec's functions that show predicates' source (e.g. s/form, s/explain)
  ;; would not work correctly.
  ;; Explanation is not necessary for generation but helps with debugging.
  (let [last-id (atom 0)
        new-tag! (fn [prefix]
                   (prefixed-key prefix (str (swap! last-id inc))))
        param-spec (fn [{pname :name ptype-name :type in :in required? :required pattern :pattern
                         :as description}]
                     (let [form `(s/tuple #{~pname} #{~in} ~(value-spec description))]
                       [(keyword pname)
                        (if required?
                          form
                          `(s/? ~form))]))
        method-spec (fn [[method props]]
                      [method
                       `(s/tuple #{~method}
                          (s/cat
                            ~@(mapcat param-spec (:parameters props))))])
        path-spec (fn [[path methods]]
                    [(new-tag! :path)
                     `(s/tuple #{~(name path)}
                        (s/alt ~@(mapcat method-spec methods)))])
        api-paths (->> api :paths)]
    (eval `(s/alt ~@(mapcat path-spec api-paths)))))


(defn load-api [openapi-definition-str]
  (let [api (s/conform :swagger/definition
              (yaml/parse-string openapi-definition-str))]
    (assert (clojure.string/starts-with? (:swagger api) "2."))
    api))


(defn speced-to-map
  "Transform call generated by spec into simpler map.
  Get rid of spec generation artifacts."
  [[[path [[method params]]]]]
  {:method method
   :path path
   :params (map (fn [[n in value]]
                  {:name n
                   :in (keyword in)
                   :value value}) params)})

(defn map-to-speced
  "Adapt request map to form that can be matched by API spec.
  Inverse of speced-to-map."
  [{method :method path :path params :params}]
  [[path [[method
           (map (fn [{n :name
                      in :in
                      value :value}]
                  [n (name in) value])
             params)]]]])


;; --------------------------------------------------------
;; Requests


(defn embed-parameter [request {param-name :name
                                value :value
                                in :in}]
  ;; Unsupported locations :query :header :formData :cookie
  (case in
    :path (update request :path
            (fn [p]
              (clojure.string/replace p
                (str "{" param-name "}")
                value)))
    :body (assoc request :body value)))


(defn prepare-request [base-path request]
  ;; TODO use base path
  (-> (reduce embed-parameter
        (dissoc request :params)
        (:params request))
    (update :path #(str base-path %))))


(defn generate-calls [api call-spec sample-count]
  (let [generated-records (-> call-spec
                            s/gen
                            (gen/sample sample-count))]
    (map (comp #(prepare-request (:basePath api) %)
           speced-to-map)
      generated-records)))
