(ns oasiege.core
  (:require [clojure.spec :as s]
            [swagger.reader.json :as json]
            [swagger.reader.yaml :as yaml]
            [clojure.spec.gen :as gen]
            swagger.spec
            clojure.string))


;; --------------------------------------------------------
;; Spec generation


(defn prefixed-key [prefix key]
  (keyword (namespace prefix)
    (str (name prefix) "." (name key))))


(defn request-spec [api]
  ;; It is possible to use s/def-impl do add definitions and avoid macroses
  ;; but then spec's explanation functions that show predicates' source
  ;; would not work correctly.
  ;; Explanation is not necessary for generation but helps with debugging.
  (let [last-id (atom 0)
        new-tag! (fn [prefix]
                   (prefixed-key prefix (str (swap! last-id inc))))
        param-spec (fn [{pname :name ptype-name :type in :in required? :required pattern :pattern :as caramba}]
                     (prn caramba)
                     (let [value-spec (case ptype-name
                                        "integer" `integer?
                                        ;; TODO Implementation use pattern to restrict string values
                                        "string" `string?
                                        ;; FIXME Handle other types (type might not be specified)
                                        nil `string?)
                           form `(s/tuple #{~pname} #{~in} ~value-spec)]
                       [(keyword pname)
                        (if required?
                          form
                          `(s/? ~form))]))
        method-spec (fn [[method props]]
                      [method
                       `(s/tuple #{~method}
                          (s/cat
                            ~@(mapcat param-spec (:parameters props))))])
        path-spec (fn [[path methods]]
                    [(new-tag! :path)
                     `(s/tuple #{~(name path)}
                        (s/alt ~@(mapcat method-spec methods)))])
        api-paths (->> api :paths)]
    (eval `(s/alt ~@(mapcat path-spec api-paths)))))


(defn load-api [openapi-definition-str]
  (let [api (s/conform :swagger/definition
              (yaml/parse-string openapi-definition-str))]
    (assert (clojure.string/starts-with? (:swagger api) "2."))
    api))


(defn speced-to-map
  "Transform call generated by spec into simpler map.
  Get rid of spec generation artifacts."
  [[[path [[method params]]]]]
  {:method method
   :path path
   :params (map (fn [[n in value]]
                  {:name n
                   :in (keyword in)
                   :value value}) params)})

(defn map-to-speced
  "Adapt request map to form that can be matched by API spec.
  Inverse of speced-to-map."
  [{method :method path :path params :params}]
  [[path [[method
           (map (fn [{n :name
                      in :in
                      value :value}]
                  [n (name in) value])
             params)]]]])


;; --------------------------------------------------------
;; Requests


(defn embed-parameter [request {param-name :name
                                value :value
                                in :in}]
  ;; Unsupported values :query :header :formData :cookie
  (case in
    :path (update request :path
            (fn [p]
              (clojure.string/replace p
                (str "{" param-name "}")
                value)))
    :body (assoc request :body value)))


(defn prepare-request [base-path request]
  ;; TODO use base path
  (-> (reduce embed-parameter
        (dissoc request :params)
        (:params request))
    (update :path #(str base-path %))))


;; --------------------------------------------------------
;; Main


(defn generate-calls [api call-spec sample-count]
  (let [generated-records (-> call-spec
                            s/gen
                            (gen/sample sample-count))]
    (map (comp #(prepare-request (:basePath api) %)
           speced-to-map)
      generated-records)))


(defn example-run []
  (let [api (load-api (slurp "test/oasiege/data/hummus.yaml"))
        rspec (request-spec api)]

    (println "Generating calls from spec...")
    (doseq [call (generate-calls api rspec 200)]
      (prn call))

    (println "Matching a call against a spec...")
    (prn (s/conform rspec
           (map-to-speced {:method :get
                           :path "/quality-label/{key}"
                           :params [{:name "key"
                                     :in :path
                                     :value "wGHi3LCS9Q8a3"}]})))))
